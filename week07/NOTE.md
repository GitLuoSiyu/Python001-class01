## 学习笔记

### python设计模式
经典的《设计模式》一书归纳出23种设计模式，这23种模式又可归为，创建型、结构型和行为型3大类，

创建型模式：
- 简单工厂模式（Simple Factory）、
- 工厂方法模式（Factory Method）、
- 抽象工厂模式（Abstract Factory）、
- 创建者模式（Builder）、
- 原型模式（Prototype）、
- 单例模式（Singleton）。

结构型模式：
- 外观模式（Facade）、
- 适配器模式（Adapter）、
- 代理模式（Proxy）、
- 装饰模式（Decorator）、
- 桥模式（Bridge）、
- 组合模式（Composite）、
- 享元模式（Flyweight）。

行为型模式：
- 模板方法模式（Template Method）、
- 观察者模式（Observer）、
- 状态模式（State）、
- 策略模式（Strategy）、
- 职责链模式（Chain of Responsibility）、
- 命令模式（Command）、
- 访问者模式（Visitor）、
- 调停者模式（Mediator）、
- 备忘录模式（Memento）、
- 迭代器模式（Iterator）、
- 解释器模式（Interpreter）。

### 面向对象的软件开发
很多人在学完了python的class机制之后，遇到一个生产中的问题，还是会懵逼，这其实太正常了，因为任何程序的开发都是先设计后编程，python的class机制只不过是一种编程方式，如果你硬要拿着class去和你的问题死磕，变得更加懵逼都是分分钟的事，在以前，软件的开发相对简单，从任务的分析到编写程序，再到程序的调试，可以由一个人或一个小组去完成。但是随着软件规模的迅速增大，软件任意面临的问题十分复杂，需要考虑的因素太多，在一个软件中所产生的错误和隐藏的错误、未知的错误可能达到惊人的程度，这也不是在设计阶段就完全解决的。

    所以软件的开发其实一整套规范，我们所学的只是其中的一小部分，一个完整的开发过程，需要明确每个阶段的任务，在保证一个阶段正确的前提下再进行下一个阶段的工作，称之为软件工程

    面向对象的软件工程包括下面几个部：

### 1.面向对象分析（object oriented analysis ，OOA）

    软件工程中的系统分析阶段，要求分析员和用户结合在一起，对用户的需求做出精确的分析和明确的表述，从大的方面解析软件系统应该做什么，而不是怎么去做。面向对象的分析要按照面向对象的概念和方法，在对任务的分析中，从客观存在的事物和事物之间的关系，贵南出有关的对象（对象的‘特征’和‘技能’）以及对象之间的联系，并将具有相同属性和行为的对象用一个类class来标识。

    建立一个能反映这是工作情况的需求模型，此时的模型是粗略的。

### 2 面向对象设计（object oriented design，OOD）

    根据面向对象分析阶段形成的需求模型，对每一部分分别进行具体的设计。

    首先是类的设计，类的设计可能包含多个层次（利用继承与派生机制）。然后以这些类为基础提出程序设计的思路和方法，包括对算法的设计。

    在设计阶段并不牵涉任何一门具体的计算机语言，而是用一种更通用的描述工具（如伪代码或流程图）来描述

### 3 面向对象编程（object oriented programming，OOP）

    根据面向对象设计的结果，选择一种计算机语言把它写成程序，可以是python

### 4 面向对象测试（object oriented test，OOT）

    在写好程序后交给用户使用前，必须对程序进行严格的测试，测试的目的是发现程序中的错误并修正它。

    面向对的测试是用面向对象的方法进行测试，以类作为测试的基本单元。

### 5 面向对象维护（object oriendted soft maintenance，OOSM）

    正如对任何产品都需要进行售后服务和维护一样，软件在使用时也会出现一些问题，或者软件商想改进软件的性能，这就需要修改程序。

    由于使用了面向对象的方法开发程序，使用程序的维护比较容易。

    因为对象的封装性，修改一个对象对其他的对象影响很小，利用面向对象的方法维护程序，大大提高了软件维护的效率，可扩展性高。

 

    在面向对象方法中，最早发展的肯定是面向对象编程(OOP),那时OOA和OOD都还没有发展起来，因此程序设计者为了写出面向对象的程序，还必须深入到分析和设计领域，尤其是设计领域，那时的OOP实际上包含了现在的OOD和OOP两个阶段，这对程序设计者要求比较高，许多人感到很难掌握。

    现在设计一个大的软件，是严格按照面向对象软件工程的5个阶段进行的，这个5个阶段的工作不是由一个人从头到尾完成的，而是由不同的人分别完成，这样OOP阶段的任务就比较简单了。程序编写者只需要根据OOd提出的思路，用面向对象语言编写出程序既可。

    在一个大型软件开发过程中，OOP只是很小的一个部分。

    对于全栈开发的你来说，这五个阶段都有了，对于简单的问题，不必严格按照这个5个阶段进行，往往由程序设计者按照面向对象的方法进行程序设计，包括类的设计和程序的设计


## 面向对象常用术语
### 抽象/实现

抽象指对现实世界问题和实体的本质表现,行为和特征建模,建立一个相关的子集,可以用于 绘程序结构,从而实现这种模型。抽象不仅包括这种模型的数据属性,还定义了这些数据的接口。

对某种抽象的实现就是对此数据及与之相关接口的现实化(realization)。现实化这个过程对于客户 程序应当是透明而且无关的。 

### 封装/接口

封装描述了对数据/信息进行隐藏的观念,它对数据属性提供接口和访问函数。通过任何客户端直接对数据的访问,无视接口,与封装性都是背道而驰的,除非程序员允许这些操作。作为实现的 一部分,客户端根本就不需要知道在封装之后,数据属性是如何组织的。在Python中,所有的类属性都是公开的,但名字可能被“混淆”了,以阻止未经授权的访问,但仅此而已,再没有其他预防措施了。这就需要在设计时,对数据提供相应的接口,以免客户程序通过不规范的操作来存取封装的数据属性。

注意：封装绝不是等于“把不想让别人看到、以后可能修改的东西用private隐藏起来”

真正的封装是，经过深入的思考，做出良好的抽象，给出“完整且最小”的接口，并使得内部细节可以对外透明

（注意：对外透明的意思是，外部调用者可以顺利的得到自己想要的任何功能，完全意识不到内部细节的存在）

### 合成

合成扩充了对类的 述,使得多个不同的类合成为一个大的类,来解决现实问题。合成 述了 一个异常复杂的系统,比如一个类由其它类组成,更小的组件也可能是其它的类,数据属性及行为, 所有这些合在一起,彼此是“有一个”的关系。

### 派生/继承/继承结构

派生描述了子类衍生出新的特性,新类保留已存类类型中所有需要的数据和行为,但允许修改或者其它的自定义操作,都不会修改原类的定义。
继承描述了子类属性从祖先类继承这样一种方式
继承结构表示多“代”派生,可以述成一个“族谱”,连续的子类,与祖先类都有关系。

### 泛化/特化

基于继承
泛化表示所有子类与其父类及祖先类有一样的特点。
特化描述所有子类的自定义,也就是,什么属性让它与其祖先类不同。

### 多态与多态性

多态指的是同一种事物的多种状态：水这种事物有多种不同的状态：冰，水蒸气

多态性的概念指出了对象如何通过他们共同的属性和动作来操作及访问,而不需考虑他们具体的类。

冰，水蒸气，都继承于水，它们都有一个同名的方法就是变成云，但是冰.变云(),与水蒸气.变云()是截然不同的过程，虽然调用的方法都一样

### 自省/反射

自省也称作反射，这个性质展示了某对象是如何在运行期取得自身信息的。如果传一个对象给你,你可以查出它有什么能力,这是一项强大的特性。如果Python不支持某种形式的自省功能,dir和type内建函数,将很难正常工作。还有那些特殊属性,像__dict__,__name__及__doc__


### 类两大成员：
- 属性
- 方法 

Python2.2以前类叫经典类，类是单独的部分，基本数据类型是另外的部分，类实现功能很难统一；Python2.2以后类叫新式类，会继承Object类，和现有的基本数据类型同源 一、属性： 类属性和对象属性 类属性 字段在内存中只有一份，当有多个引用，节省了内存 对象属性 在每个对象都保存一份，当数据在不同作用域下需要存储多份数据
```python
1.class Human(object):
    # 静态字段
    live = True
    def __init__(self, name):
        # 普通字段
        self.name = name
```

2.__dict__都可以取到作用域里面定义的所有属性

3.注意！
	# 实例可以使用普通字段也可以使用静态字段
	#如果实例引用一个不存在的属性，python会自动创建这个属性
	man.name
	man.live = False
	#False
	man.live
	
	#woman也可以访问到新创建的属性，因为是Human的实例，所以访问到live=True
	woman.live
	
	# 类可以使用静态字段
	Human.live

4.区分类是否为同一个对象
	type(a)
	id(a)
	a.__class__()

5.查看类的属性：
	dir(Human) 列表的形式来查看属性
	Human.__dict__
	
	# 内置类型不能增加属性和方法
	setattr(list, 'newattr', 'value')
	
	当对一个实例的属性去修改的时候，不会影响其他实例

5.三种不同下划线命名的属性：
	class Human2(object):
	    # 人为约定不可修改，常为内部属性，中间值属性，可见不修改
	    _age = 0
	    # 私有属性，防止人为修改或程序误修改，可以访问到但是不推荐访问
	    __fly = False
	    # 魔术方法，不会自动改名，跟随系统发生变化
	    # 如 __init__
	
	# 自动改名机制
	Human2.__dict__
	
	显示object类的所有子类
	print( ().__class__.__bases__[0].__subclasses__() )
	
	type(()) 是个元组
	().__class__.__bases__类的父类是object
	().__class__.__bases__[0]从tuple中把元素释放，object类

### 方法 
• 普通方法（实例方法）至少一个self参数，表示该方法的对象 
• classmethod类方法 至少一个cls参数，表示该方法的类 
• staticmethod静态方法 由类调用，无参数

后两种属于语法糖：原有语法基础上增加特殊功能 @classmethod

classmethod 相当于一个构造函数，类中只有一个构造函数__new__，所以产生classmethod。实例和类都可以使用，如果实例没有该属性就去找类的属性。

classmethod好处：p5_1classmethod.py
- 1.在父类中定义classmethod，子类需要根据自己的变量名称发生变化，这里子类和父类id不同
- 2函数需要调用类中的方法并返回，提前做预处理
staticmethod 没有参数self 和 cls，不能用到类和实例的属性 作用：某个功能频繁使用，如类型转换；增加某些特定的判断。
两者区别： staticmethod没有参数self 和 cls，不能用到类和实例的属性，主要用于额外处理的逻辑 classmethod主要作为构造函数

### 高级描述器 
1.对实例获取属性： 
getattribute()： 对所有属性的访问都会调用该方法 
__getattr()：适用于未定义的属性

如果这俩方法同时存在，执行顺序是 __getattribute__ > __getattr__ > __dict__
注意：
1.无论属性是否存在都会调用__getattribute__，损耗性能
2.调用完__getattr__,利用hasattr判断属性能返回true，但是dict里依然没有属性，这两者不一致
2.属性描述符property 是一个类， 功能：1）把方法封装成属性 2）读写分离，分权限控制property property类需要实现__get__、set、delete

# property本质并不是函数，而是特殊类（实现了数据描述符的类） # 如果一个对象同时定义了__get__()和__set__()方法，则称为数据描述符， # 如果仅定义了__get__()方法，则称为非数据描述符 # property的优点： # 1 代码更简洁，可读性、可维护性更强。 # 2 更好的管理属性的访问。 # 3 控制属性访问权限，提高数据安全性。

### 继承
Python支持单继承，也支持多继承（missing解决） 新式类，所有类都继承一个父类，Object类

object和type的关系：
	○ object和type都属于type类，都由元类type创建
	○ object的父类为空，没有继承任何类
	○ type的父类是object类
类的继承 • 单一继承 • 多重继承 • 菱形继承（钻石继承）：去父类找，父类没有就去父类的父类去找 • 继承机制MRO • MRO的C3算法
























